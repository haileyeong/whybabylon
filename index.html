<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Babylon.js Playground</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <!-- Babylon globals (kept so window.BABYLON is available if your app expects it) -->
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://cdn.babylonjs.com/recast.js"></script>
    <script src="https://cdn.babylonjs.com/ammo.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/Oimo.js"></script>
    <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }

        #renderCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0; /* 캔버스는 뒤에 */
            width: 100%;
            height: 100%;
        }

        #overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 1; /* 텍스트는 앞에 */
        }
    </style>

</head>
<body>
    <div id="overlay">
       <h4>여기에 어떻게 오 셨 죠 . . .</h4>
       <p>현재 시간: <span id="clock">00:00:00</span></p>
    </div>

    <script>
        function getClock() {
            const date = new Date();
            const timeString = date.toLocaleTimeString();

            document.getElementById("clock").innerText = timeString;
        }

        setInterval(getClock, 1000);

        getClock();
    </script>

   <canvas id="renderCanvas"></canvas>
    <script type="module">
        // Turn bundle text into a module URL
        const code = "// snapshot:index.js\nvar createScene = function() {\n  var scene = new BABYLON.Scene(engine);\n  var camera = new BABYLON.ArcRotateCamera(\"camera\", BABYLON.Tools.ToRadians(90), BABYLON.Tools.ToRadians(65), 10, BABYLON.Vector3.Zero(), scene);\n  camera.setTarget(BABYLON.Vector3.Zero());\n  camera.attachControl(canvas, true);\n  var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\n  light.intensity = 0.7;\n  var ground = BABYLON.MeshBuilder.CreateGround(\"ground\", { width: 6, height: 6 }, scene);\n  let groundMaterial = new BABYLON.StandardMaterial(\"Ground Material\", scene);\n  let groundTexture = new BABYLON.Texture(Assets.textures.checkerboard_basecolor_png.path, scene);\n  groundMaterial.diffuseColor = BABYLON.Color3.Red();\n  groundMaterial.diffuseTexture = groundTexture;\n  ground.material = groundMaterial;\n  BABYLON.ImportMeshAsync(Assets.meshes.Yeti.rootUrl + Assets.meshes.Yeti.filename, scene).then(function({ meshes }) {\n    meshes[0].scaling = new BABYLON.Vector3(0.1, 0.1, 0.1);\n  });\n  return scene;\n};\nvar index_default = createScene;\nexport {\n  createScene,\n  index_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic25hcHNob3Q6aW5kZXguanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImV4cG9ydCBjb25zdCBjcmVhdGVTY2VuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGlzIGNyZWF0ZXMgYSBiYXNpYyBCYWJ5bG9uIFNjZW5lIG9iamVjdCAobm9uLW1lc2gpXG4gICAgdmFyIHNjZW5lID0gbmV3IEJBQllMT04uU2NlbmUoZW5naW5lKTtcblxuICAgIHZhciBjYW1lcmEgPSBuZXcgQkFCWUxPTi5BcmNSb3RhdGVDYW1lcmEoXCJjYW1lcmFcIiwgQkFCWUxPTi5Ub29scy5Ub1JhZGlhbnMoOTApLCBCQUJZTE9OLlRvb2xzLlRvUmFkaWFucyg2NSksIDEwLCBCQUJZTE9OLlZlY3RvcjMuWmVybygpLCBzY2VuZSk7XG5cbiAgICAvLyBUaGlzIGNyZWF0ZXMgYW5kIHBvc2l0aW9ucyBhIGZyZWUgY2FtZXJhIChub24tbWVzaClcbiAgICAvLyB2YXIgY2FtZXJhID0gbmV3IEJBQllMT04uRnJlZUNhbWVyYShcImNhbWVyYTFcIiwgbmV3IEJBQllMT04uVmVjdG9yMygwLCA1LCAtMTApLCBzY2VuZSk7XG5cbiAgICAvLyBUaGlzIHRhcmdldHMgdGhlIGNhbWVyYSB0byBzY2VuZSBvcmlnaW5cbiAgICBjYW1lcmEuc2V0VGFyZ2V0KEJBQllMT04uVmVjdG9yMy5aZXJvKCkpO1xuXG4gICAgLy8gVGhpcyBhdHRhY2hlcyB0aGUgY2FtZXJhIHRvIHRoZSBjYW52YXNcbiAgICBjYW1lcmEuYXR0YWNoQ29udHJvbChjYW52YXMsIHRydWUpO1xuXG4gICAgLy8gVGhpcyBjcmVhdGVzIGEgbGlnaHQsIGFpbWluZyAwLDEsMCAtIHRvIHRoZSBza3kgKG5vbi1tZXNoKVxuICAgIHZhciBsaWdodCA9IG5ldyBCQUJZTE9OLkhlbWlzcGhlcmljTGlnaHQoXCJsaWdodFwiLCBuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDEsIDApLCBzY2VuZSk7XG5cbiAgICAvLyBEZWZhdWx0IGludGVuc2l0eSBpcyAxLiBMZXQncyBkaW0gdGhlIGxpZ2h0IGEgc21hbGwgYW1vdW50XG4gICAgbGlnaHQuaW50ZW5zaXR5ID0gMC43O1xuXG4gICAgLy8gT3VyIGJ1aWx0LWluICdncm91bmQnIHNoYXBlLlxuICAgIHZhciBncm91bmQgPSBCQUJZTE9OLk1lc2hCdWlsZGVyLkNyZWF0ZUdyb3VuZChcImdyb3VuZFwiLCB7d2lkdGg6IDYsIGhlaWdodDogNn0sIHNjZW5lKTtcbiAgICBsZXQgZ3JvdW5kTWF0ZXJpYWwgPSBuZXcgQkFCWUxPTi5TdGFuZGFyZE1hdGVyaWFsKFwiR3JvdW5kIE1hdGVyaWFsXCIsIHNjZW5lKTtcbiAgICBsZXQgZ3JvdW5kVGV4dHVyZSA9IG5ldyBCQUJZTE9OLlRleHR1cmUoQXNzZXRzLnRleHR1cmVzLmNoZWNrZXJib2FyZF9iYXNlY29sb3JfcG5nLnBhdGgsIHNjZW5lKTtcbiAgICBncm91bmRNYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBCQUJZTE9OLkNvbG9yMy5SZWQoKTtcbiAgICBncm91bmRNYXRlcmlhbC5kaWZmdXNlVGV4dHVyZSA9IGdyb3VuZFRleHR1cmU7XG4gICAgZ3JvdW5kLm1hdGVyaWFsID0gZ3JvdW5kTWF0ZXJpYWw7XG5cbiAgICBCQUJZTE9OLkltcG9ydE1lc2hBc3luYyhBc3NldHMubWVzaGVzLllldGkucm9vdFVybCArIEFzc2V0cy5tZXNoZXMuWWV0aS5maWxlbmFtZSwgc2NlbmUpLnRoZW4oZnVuY3Rpb24gKHttZXNoZXN9KSB7XG4gICAgICAgIG1lc2hlc1swXS5zY2FsaW5nID0gbmV3IEJBQllMT04uVmVjdG9yMygwLjEsIDAuMSwgMC4xKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzY2VuZTtcblxufTtcbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVNjZW5lXG5cbi8vIyBzb3VyY2VVUkw9ZmlsZTovLy9wZy9pbmRleC5qcyJdLAogICJtYXBwaW5ncyI6ICI7QUFBTyxJQUFNLGNBQWMsV0FBWTtBQUVuQyxNQUFJLFFBQVEsSUFBSSxRQUFRLE1BQU0sTUFBTTtBQUVwQyxNQUFJLFNBQVMsSUFBSSxRQUFRLGdCQUFnQixVQUFVLFFBQVEsTUFBTSxVQUFVLEVBQUUsR0FBRyxRQUFRLE1BQU0sVUFBVSxFQUFFLEdBQUcsSUFBSSxRQUFRLFFBQVEsS0FBSyxHQUFHLEtBQUs7QUFNOUksU0FBTyxVQUFVLFFBQVEsUUFBUSxLQUFLLENBQUM7QUFHdkMsU0FBTyxjQUFjLFFBQVEsSUFBSTtBQUdqQyxNQUFJLFFBQVEsSUFBSSxRQUFRLGlCQUFpQixTQUFTLElBQUksUUFBUSxRQUFRLEdBQUcsR0FBRyxDQUFDLEdBQUcsS0FBSztBQUdyRixRQUFNLFlBQVk7QUFHbEIsTUFBSSxTQUFTLFFBQVEsWUFBWSxhQUFhLFVBQVUsRUFBQyxPQUFPLEdBQUcsUUFBUSxFQUFDLEdBQUcsS0FBSztBQUNwRixNQUFJLGlCQUFpQixJQUFJLFFBQVEsaUJBQWlCLG1CQUFtQixLQUFLO0FBQzFFLE1BQUksZ0JBQWdCLElBQUksUUFBUSxRQUFRLE9BQU8sU0FBUywyQkFBMkIsTUFBTSxLQUFLO0FBQzlGLGlCQUFlLGVBQWUsUUFBUSxPQUFPLElBQUk7QUFDakQsaUJBQWUsaUJBQWlCO0FBQ2hDLFNBQU8sV0FBVztBQUVsQixVQUFRLGdCQUFnQixPQUFPLE9BQU8sS0FBSyxVQUFVLE9BQU8sT0FBTyxLQUFLLFVBQVUsS0FBSyxFQUFFLEtBQUssU0FBVSxFQUFDLE9BQU0sR0FBRztBQUM5RyxXQUFPLENBQUMsRUFBRSxVQUFVLElBQUksUUFBUSxRQUFRLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDekQsQ0FBQztBQUVELFNBQU87QUFFWDtBQUNBLElBQU8sZ0JBQVE7IiwKICAibmFtZXMiOiBbXQp9Cg==\n";
        const blob = new Blob([code], { type: 'text/javascript' });
        const url = URL.createObjectURL(blob);

        const BABYLON = window.BABYLON;
        const canvas = document.getElementById('renderCanvas');

        // Import your bundled app (which exports createScene / default)
        const mod = await import(url);

        let engine = null;
        if (typeof mod.createEngine === 'function') {
            try { engine = await mod.createEngine(); } catch { }
        }
        if (!engine) {
            engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        }
        window.engine = engine; window.canvas = canvas;

        let createScene = mod.createScene || mod.default;
        if (!createScene && mod.Playground?.CreateScene) createScene = (e, c) => mod.Playground.CreateScene(e, c);
        if (!createScene) throw new Error('No createScene() export found.');

        const scene = await(createScene(engine, canvas) ?? createScene());
        engine.runRenderLoop(() => scene.render());
        addEventListener('resize', () => engine.resize());

        addEventListener('unload', () => URL.revokeObjectURL(url));
    </script>
</body>
</html>